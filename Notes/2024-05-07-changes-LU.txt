NOTE:
* idea for a future style implementation: see bottom of this file

TODO:
* change all checks of XMLNode with unspecified_bool_type to node.empty() checks (verified to be the same underlying logic)
* check all TODO entries in code

later (tm):
* in a later patch: replace leap year logic per XLDateTime.cpp with c++ built-in date functions

TBD:
----
* in XLWorkbook::setSheetIndex: What does this section do: // ===== Updated defined names with worksheet scopes. ???
* in XLWorkbook::updateSheetReferences: What does this function actually do (TBD to verify definedNames logic)???
* Pull request #191: can AmigaOS support ""/file-in-local-folder.xlsx, using "" as local folder?

TBC:
----
* Does zippy.hpp line 10614 have bug in the return statement of the lambda to erase files from the result:
                                            return (subFolderDepth == rootDepth && filename.back() != '/') || (subFolderDepth > rootDepth);
?
If I don't misread this, the condition filename.back() != '/' would delete all filenames from the result that are not directories, which would be in contradiction to the function description
         * @brief Get a list of the entries in a specific directory of the archive. Depending on the input parameters,
         * the list will include directories, files or both.

CONFIRMED:
* XLCellReference constructor shall throw exception on empty string
* node.empty() works on empty nodes, e.g.: XLMNode node() // --> node.empty() evaluates to true
* Does an XLSX column type t default to "n" numeric? Because OpenXLSX does not add the t field for numbers:
-> no type == generic value (for any application reading)

2024-05-07:
===========

IMPLEMENTED:
--------------------------
Pull Request: Set uniqueCount correctly in sharedStrings.xml #192
confirmed & implemented, but by removing count & uniqueCount attributes from shared strings table as both belong together but are optional
--> implemented
affects:
  OpenXLSX/sources/XLDocument.cpp
481,490c481
<     XMLDocument * sharedStrings = getXmlData("xl/sharedStrings.xml")->getXmlDocument();
<     if( !sharedStrings->document_element().attribute("uniqueCount").empty() ) {
<         // std::cout << "shared strings had uniqueCount" << std::endl;
<         sharedStrings->document_element().remove_attribute("uniqueCount"); // pull request #192 -> remove count & uniqueCount as they are optional
<     }
<     if( !sharedStrings->document_element().attribute("count").empty() ) {
<         // std::cout << "shared strings had count" << std::endl;
<         sharedStrings->document_element().remove_attribute("count");       // pull request #192 -> remove count & uniqueCount as they are optional
<     }
<     XMLNode node = sharedStrings->document_element().first_child_of_type(pugi::node_element); // pull request #186: Skip non-element nodes in sst.
---
>     XMLNode node = getXmlData("xl/sharedStrings.xml")->getXmlDocument()->document_element().first_child_of_type(pugi::node_element); // pull request #186: Skip non-element nodes in sst.
876,877c867
<                     // "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"1\" uniqueCount=\"1\">\n"
<                     "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">\n" // pull request #192 -> remove count & uniqueCount as they are optional
---
>                     "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"1\" uniqueCount=\"1\">\n"


my own patches:
---------------
Patch #42: support in zippy & Demo4 & CMakeLists.txt for ENABLE_NOWIDE:
CMakeLists.txt:
option(OPENXLSX_ENABLE_NOWIDE "Enable using nowide" OFF)
  [..]
if(${OPENXLSX_ENABLE_NOWIDE})
    add_compile_definitions(ENABLE_NOWIDE)
endif()

Patch #41: new overload for << operator on XLFormulaProxy to output the formula string to std::ostream

Patch #40: new instances of getString for XLCell, XLCellValueProxy

Patch #39: new class XLCellAssignable, returned by XLSheet::cell(const std::string& ref) const;
          (future: could also be returned for the other parameter invocations of ::cell)
Purpose: return a temporary object that has an assignment operator = overload that will allow to assign a value to the cell (or copy from one cell to another)
 This class also features an overload for << operator to output the cell value (as string) to std::ostream

Patch #38: BUGFIX in XLCell::copyFrom: iteration over other.m_cellNode children was not incrementing the child to next sibling -> infinite loop
-155
        for (XMLNode child = other.m_cellNode->first_child(); !child.empty(); child = other.m_cellNode->next_sibling())
+155
        for (XMLNode child = other.m_cellNode->first_child(); !child.empty(); child = child.next_sibling())


2024-05-03:
===========

my own patches:
---------------
Patch #37: support direct copy assignment from one XLCell to another
affects:
  OpenXLSX/sources/XLCell.cpp XLCell& XLCell::operator=(const XLCell& other)
  OpenXLSX/headers/XLFormula.hpp setFormulaString -> added param bool resetValue = XLResetValue
-316
         * @param formulaString String holding the formula.
         */
        void setFormulaString(const char* formulaString);
+316
         * @param formulaString String holding the formula.
			* @param resetValue if true (XLResetValue), the cell value will be set to 0, if false (XLPreserveValue), it will remain unchanged
         */
        void setFormulaString(const char* formulaString, bool resetValue = XLResetValue);
  OpenXLSX/sources/XLFormula.cpp
-150
void XLFormulaProxy::setFormulaString(const char* formulaString) {
+150
void XLFormulaProxy::setFormulaString(const char* formulaString, bool resetValue) {
-165
    m_cellNode->child("v").text().set(0);
+165
    if( resetValue )
        m_cellNode->child("v").text().set(0);


Patch #36: support for multi-element simple <t> strings in sharedStrings table
affects:
  OpenXLSX/sources/XLDocument.cpp XLDocument::open
-499 (don't have old code right now)
+499
            // ===== If shared string is a regular string
            else { // 2024-05-03: support a string composed of multiple <t> nodes, because LibreOffice accepts it
                std::string result;
                while (elem) {
                    if( elem.name() != "t"s ) throw XLInputError( "xl/sharedStrings.xml si node \""s + node.name() + "\" is neiter \"r\" not \"t\""s );
                    result += elem.text().get();
                    elem = elem.next_sibling_of_type(pugi::node_element);
                }
                m_sharedStringCache.emplace_back(result);
            }


2024-05-02:
===========

DONE:
* Revised all code to search for whitespace-compatible use of:
  - all occurrences of previous_sibling
  - all occurrences of next_sibling
  - all occurrences of first_child
  - all occurrences of last_child
  - all occurrences of loops using an iterator (for (auto x : node.children), auto x = node.begin), etc)

IMPLEMENTED:
--------------------------
Pull Request: add XLCellValue::to_variant to use std::visit #127
todo: assess usefulness of non-const return value getVariant (listed in above TODO-list)
confirmed & implemented in Patch #1 and additionally here
--> implemented
affects:
  OpenXLSX/headers/XLCellValue.hpp

Pull Request: Ensure a valid result when using XLCellValue::get<std::string>() #158
--> implemented in Patch #1 -> XLCellValue::getAsString() provides the desired functionality

Pull Request: Fix XLCell copy operator #160
Confirmed & fixed
--> implemented
affects:
  OpenXLSX/sources/XLCell.cpp XLCell& XLCell::operator=(XLCell&& other) noexcept
+125
        m_formulaProxy  = XLFormulaProxy(this, m_cellNode.get()); // pull request #160

Pull Request: Fix crash when using XLCellProxyValue()::set() with an empty string #161
Confirmed undefined behavior, fixed
--> implemented
affects:
  OpenXLSX/sources/XLSharedStrings int32_t XLSharedStrings::appendString(const std::string& str)
-105
    if (str.front() == ' ' || str.back() == ' ') textNode.append_attribute("xml:space").set_value("preserve");
+105
    if ((!str.empty()) && (str.front() == ' ' || str.back() == ' ')) textNode.append_attribute("xml:space").set_value("preserve");

Pull Request: Use a regex to parse XLProperty::AppVersion #162 
Confirmed & fixed, but using new function getAppVersion instead, because including regex is costly, this is the only use case and it increases the size of the library file by 1.5 Megabytes (ca. 28%)!
--> implemented
affects (same as pull request #174):
  OpenXLSX/sources/XLDocument.cpp XLDocument::setProperty and bool getAppVersion( std::string versionString, int & majorVersion, int & minorVersion ) (new private function)

Pull Request: Explicitely cast to unsigned short int #163
Duplicates:   Update XLSheet.cpp with correct type #176 (implemented)

Pull Request: Fixing discarding return value of function with 'nodiscard' attribute #174
Issue tested, confirmed & fixed (including TODO cleanup of the section)
--> implemented
affects:
  OpenXLSX/sources/XLDocument.cpp XLDocument::setProperty and bool getAppVersion( std::string versionString, int & majorVersion, int & minorVersion ) (new private function)



my own patches:
---------------

PATCH #35: improved logic for XLAppProperties::deleteHeadingPair(const std::string& name)
affects:
  OpenXLSX/sources/XLProperties.cpp
-264
            while (count && (item.next_sibling() != count)) HeadingPairsNode.remove_child(item.next_sibling()); // remove all nodes between element nodes to be deleted jointly
            HeadingPairsNode.remove_child(count);
+264
            if( !count.empty() ) { // 2024-05-02: TBD that change to loop deleting whitespaces following a count node is bug-free
                while (item.next_sibling() != count) HeadingPairsNode.remove_child(item.next_sibling()); // remove all nodes between element nodes to be deleted jointly
                HeadingPairsNode.remove_child(count);
				}

PATCH #34: simplified XLWorkbook::deleteNamedRanges:
affects:
  OpenXLSX/sources/XLWorkbook.cpp
void XLWorkbook::deleteNamedRanges()
-185
    for (auto& child : xmlDocument().document_element().child("definedNames").children()) child.parent().remove_child(child);
+185
    xmlDocument().document_element().child("definedNames").remove_children(); // 2024-05-02: why loop if pugixml has a function for "delete all children"?
    // for (auto& child : xmlDocument().document_element().child("definedNames").children()) child.parent().remove_child(child);


PATCH #33: added an early (whitespace) skip in the lambda function used to determine worksheetCount
affects:
  OpenXLSX/sources/XLWorkbook.cpp
+202
            if( item.type() != pugi::node_element ) return false; // 2024-05-02 this avoids the unnecessary query below

Patch #32: BUGFIX void XLWorkbook::deleteSheet - param sheetID for sheetTypeQuery was using relationshipID() instead of sheetID, leading to a bad sheetType & a failed check to not delete last worksheet
affects:
  OpenXLSX/sources/XLWorkbook.cpp
-196
    sheetTypeQuery.setParam("sheetID", relationshipID());
+196
    sheetTypeQuery.setParam("sheetID", std::string(sheetID)); // BUGFIX 2024-05-02: was using relationshipID() instead of sheetID, leading to a bad sheetType & a failed check to not delete last worksheet


2024-05-01:
===========

my own patches:
---------------
Patch #31: Whitespace support done for:
- XLWorkbook.hpp & .cpp // CAUTION: execCommand on underlying XML with whitespaces not verified in function void XLWorkbook::deleteSheet(const std::string& sheetName)
  * rewrote XLWorkbook::setSheetIndex
    ==> SOLVED: @todo In some cases (eg. if a sheet is moved to the position before the selected sheet), multiple sheets are selected when opened in Excel.

- (no changes) XLXmlData.hpp & .cpp
- (no changes) XLXmlFile.hpp & .cpp
- (no changes) XLXmlParser.hpp (header only)
- (no changes) XLZipArchive & .cpp

===> WHITESPACE SUPPORT COMPLETED

Patch #30: convenience features
* added private functions XLWorkbook::isVisibleState and ::isVisible to test an XMLNode state attribute in a single location, consistently, addressing bugfixes as per Patch #28 & #29
* changed XLDocument execCommand to return a bool success state (if underlying command supports it), currently only used in setSheetActive
* changed all instances of setSheetActive to return a bool (true if successful activation)
* added function XLSheet::isSelected
* added to XLSheet and XLWorkbook a new member function print( std::basic_ostream<char, std::char_traits<char> >& os ) that invokes xml_node::print for outputting the XML data
affects:
  OpenXLSX/headers/XLSheet.hpp
  OpenXLSX/sources/XLSheet.cpp
  OpenXLSX/headers/XLWorkbook.hpp
  OpenXLSX/sources/XLWorkbook.cpp


Patch #29: BUGFIX XLWorkbook.cpp setSheetActive: veryHidden was not checked when hiding the active sheet & trying to find first visible sheet
affects:
  OpenXLSX/sources/XLWorkbook.cpp setSheetActive
675,676c701,702
<     while( !item.empty() ) {
<         if ((std::string(item.attribute("r:id").value()) == sheetRID ) && (std::string(item.attribute("state").value()) != "hidden")) break; // if sheet is not hidden, it can be set active
---
>     // ===== Attempting to set a hidden sheet active will remove the activeTab property from the workbook.xml sheets node
>     if (item.empty() || !isVisible(item)) // if sheet was not found or is hidden, it can not be set active. 2024-05-01 BUGFIX: veryHidden was not checked


Patch #28: BUGFIX XLWorkbook.cpp setSheetActive: old check was testing state != "hidden" || != "veryHidden", which was always true
affects:
  OpenXLSX/sources/XLWorkbook.cpp setSheetActive
385c386
<             if (!item.attribute("state") || std::string(item.attribute("state").value()) != "hidden" || std::string(item.attribute("state").value()) != "veryHidden")
---
>             if (isVisible(item)) { // BUGFIX 2024-05-01: old check was testing state != "hidden" || != "veryHidden", which was always true


Patch #27: BUGFIX XLSheet.cpp tabIsSelected: .value() "0" was evaluating to true
affects:
  OpenXLSX/sources/XLSheet.cpp tabIsSelected
98c102
<         return xmlDocument.document_element().child("sheetViews").first_child_of_type(pugi::node_element).attribute("tabSelected").value();
---
>         return xmlDocument.document_element().child("sheetViews").first_child_of_type(pugi::node_element).attribute("tabSelected").as_bool(); // BUGFIX 2024-05-01: .value() "0" was evaluating to true


Patch #26: BUGFIX XLSheet.cpp setTabSelected: create tabSelected attribute if it does not exist
affects:
  OpenXLSX/sources/XLSheet.cpp setTabSelected
89c89,92
<         xmlDocument.document_element().child("sheetViews").first_child_of_type(pugi::node_element).attribute("tabSelected").set_value(value);
---
> 		  XMLNode sheetView = xmlDocument.document_element().child("sheetViews").first_child_of_type(pugi::node_element);
> 		  XMLAttribute tabSelected = sheetView.attribute("tabSelected");
> 		  if( tabSelected.empty() ) sheetView.prepend_attribute("tabSelected"); // BUGFIX 2024-05-01: create tabSelected attribute if it does not exist
> 		  tabSelected.set_value(value);


2024-04-30:
===========

my own patches:
---------------
Patch #25: Added an output formatting function to obtain a string representation of XLContentType
affects:
  OpenXLSX/sources/utilities/XLUtilities.hpp inline std::string XLContentTypeString( OpenXLSX::XLContentType const & t )

Patch #24: Whitespace support done for:
- XLRowData.hpp & .cpp
- XLSharedStrings.hpp & .cpp
- XLSheet.hpp & .cpp
- XLWorkbook.hpp & .cpp // CAUTION: execCommand on underlying XML with whitespaces not verified in function void XLWorkbook::deleteSheet(const std::string& sheetName)
--> WORK IN PROGRESS: change activeTab value logic to a sequential index, NOT r:Id


2024-04-29:
===========
Pull request: Update XLSheet.cpp with correct type #176 
Checked (underlying type is uint16_t for XLCellReference::column()) & fixed
--> implemented
affects:
  OpenXLSX/headers/XLRow.hpp
169c169
<         uint16_t cellCount() const;
---
>         unsigned int cellCount() const;

  OpenXLSX/sources/XLRow.cpp
233c233
<     uint16_t XLRow::cellCount() const
---
>     unsigned int XLRow::cellCount() const

  OpenXLSX/sources/XLSheet.cpp uint16_t XLWorksheet::columnCount()
<         std::vector<uint16_t> counts; // Pull request: Update XLSheet.cpp with correct type #176 
---
>         std::vector<int16_t> counts;


Patch #23: Whitespace support done for:
- XLRelationships.hpp & .cpp
- XLRow.hpp & .cpp


2024-04-28:
===========
Pull Request: Support Windows and AmigaOS style paths #191
Checked & fixed
--> implemented
affects:
  OpenXLSX/external/zippy/zippy.hpp void ZipArchive::Save(std::string filename = "")

Pull Request: Fixed this-pointer check in XLCell #200
All obsolete checks removed for this == nullptr and according exceptions
--> implemented
affects:
  OpenXLSX/sources/XLCell.cpp

Patch #22: Whitespace support done for:
- utilities/XLUtilities.hpp
- XLCell.hpp & .cpp
- XLCellIterator.hpp & .cpp
- (no changes) XLCellRange.hpp & .cpp
- (no changes) XLCellReference.hpp & .cpp
- (no changes) XLCellValue.hpp & .cpp
- (no changes) XLColor.hpp & .cpp
- (no changes) XLColumn.hpp & .cpp
- (no changes) XLCommandQuery.hpp
- (no changes) XLConstants.hpp
- XLContentTypes.hpp & .cpp
- (no changes) XLDateTime.hpp & .cpp
- XLDocument.hpp & .cpp
- XLException.hpp
- XLFormula.hpp & .cpp
- (no changes) XLIterator.hpp
- XLProperties.hpp & XLProperties.cpp


my own patches:
---------------
Patch #23: Whitespace support in XLContentTypes.cpp
affects:
  OpenXLSX/sources/XLContentTypes.cpp
    void XLContentTypes::addOverride(const std::string& path, XLContentType type)
   and
    std::vector<XLContentItem> XLContentTypes::getContentItems()

Patch #22: TBD BUGFIX: XLCellValue::type: should not check empty node against nullptr (5x changed to bool comparison)
affects:
  OpenXLSX/sources/XLCellValue.cpp XLValueType XLCellValueProxy::type() const

Patch #21: (commented out) added testing function // void XLAppProperties::testFunction()
affects:
  OpenXLSX/sources/XLProperties.cpp
  OpenXLSX/sources/XLProperties.hpp

Patch #20: new pugixml function to support Patch #19
      size_t child_count_of_type(xml_node_type type = node_element) const;
  to deal with whitespaces in OpenXLSX when counting node element children
affects:
  OpenXLSX/external/pugixml/pugixml.hpp
  OpenXLSX/external/pugixml/pugixml.cpp

Patch #19 completed: Whitespace support and bugfixes in XLProperties.cpp
- removed functions because XLSX app.xml HeadingPairs tag is formatted differently
    inline XMLNode headingPairsCategories(XMLNode docNode)
    inline XMLNode headingPairsCounts(XMLNode docNode)
- accordingly fixed & tested functions
    void XLAppProperties::addHeadingPair(const std::string& name, int value) // TBD remains: should an existing name have it's value modified?
    void XLAppProperties::deleteHeadingPair(const std::string& name)
    void XLAppProperties::setHeadingPair(const std::string& name, int newValue)
- fixed & tested function
    void XLAppProperties::insertSheetName(const std::string& sheetName, unsigned int index)
- added functions
    inline XMLNode headingPairsNode(XMLNode docNode)
    inline std::vector<std::string> headingPairsCategoriesStrings(XMLNode docNode) // currently unused utility function: return a vector of existing pairs categories
affects:
  OpenXLSX/sources/XLProperties.cpp - all functions


2024-04-27:
===========

my own patches:
---------------
Patch #19: 2024-04-28 01:11: WORK IN PROGRESS - Whitespace support and bugfixes in XLProperties.cpp
TODO:
  - fix addHeadingPair
  - fix deleteHeadingPair
  - fix setHeadingPair
  - TEST insertSheetName
  - remove (or make a proper method): void printSheetNames() from XLProperties.hpp & .cpp
affects:
  OpenXLSX/sources/XLProperties.cpp - all functions

Patch #18: Whitespace support and bugfixes in column splitting logic in XLWorksheet::column
affects:
  OpenXLSX/sources/XLSheet.cpp XLColumn XLWorksheet::column(uint16_t columnNumber) const

Patch #17: Whitespace support in column splitting logic in XLWorksheet constructor, TODO test was performed, functionality is working as intended
affects:
  OpenXLSX/sources/XLSheet.cpp XLWorksheet::XLWorksheet(XLXmlData* xmlData) : XLSheetBase(xmlData)

Patch #16: Whitespace support in XLSheet.cpp XLWorksheet::column(uint16_t columnNumber) const
CAUTION: potential bugs in column splitting logic - to be discussed
affects:
  OpenXLSX/sources/XLSheet.cpp

Patch #15: replaced XLSheet.cpp XLWorksheet::cell method content mostly with XLUtilities.hpp getCellNode, which got an optional parameter rowNumber
affects:
  OpenXLSX/sources/XLSheet.cpp function XLCell XLWorksheet::cell(uint32_t rowNumber, uint16_t columnNumber) const
  OpenXLSX/sources/XLCellIterator.cpp
54d53
< #include "utilities/XLUtilities.hpp"
56a56,61
> 
> namespace OpenXLSX
> {
>     XMLNode getRowNode(XMLNode sheetDataNode, uint32_t rowNumber);
>     XMLNode getCellNode(XMLNode rowNode, uint16_t columnNumber);
> }    // namespace OpenXLSX


Patch #14: Reworked XLUtilities.hpp getCellNode to be able to ignore nodes other than node_element
affects:
  OpenXLSX/sources/utilities/XLUtilities.hpp inline XMLNode getCellNode(XMLNode rowNode, uint16_t columnNumber, uint32_t rowNumber = 0 )

Patch #13: Whitespace support in XLRowDataIterator::operator++()
affects:
  OpenXLSX/sources/XLRowData.cpp XLRowDataIterator& XLRowDataIterator::operator++()
126c126
<         auto cellNode   = m_currentCell.m_cellNode->next_sibling_of_type(pugi::node_element);
---
>         auto cellNode   = m_currentCell.m_cellNode->next_sibling();
128,129c128,129
<         // ===== If the cellNumber exceeds the last column in the range,
<         // ===== m_currentCell is set to an empty XLCell, indicating the end of the range has been reached.
---
>         // ===== If the cellNumber exceeds the last column in the range has been reached, and the m_currentCell
>         // ===== is set to an empty XLCell, indicating the end of the range has been reached.


2024-04-26:
===========

my own patches:
---------------

Patch #12: BUGFIX in XLRowDataIterator::operator++(): check was for m_cellNode->empty(), allowing an invalid test for the attribute r, discovered because the modified XLCellReference throws an exception on invalid parameter (Patch #4)
affects:
  OpenXLSX/sources/XLRowData.cpp XLRowDataIterator& XLRowDataIterator::operator++()
132c132
<         // ====== If the cellNode is null (i.e. no more children in the current row node) or the column number of the cell node
---
>         // ====== If the m_cellNode is null (i.e. no more children in the current row node) or the column number of the cell node
137,141c137
< 
<         // BUG BUGFIX 2024-04-26: check was for m_cellNode->empty(), allowing an invalid test for the attribute r, discovered
<         //       because the modified XLCellReference throws an exception on invalid parameter
<         //  this BUGFIX should explain the TODO above
<         else if (cellNode.empty() || XLCellReference(cellNode.attribute("r").value()).column() > cellNumber) { // TBD if > operator can remain as per above TODO
---
>         else if (m_cellNode->empty() || XLCellReference(cellNode.attribute("r").value()).column() != cellNumber) {

Patch #11: 
Implemented an XLRowDataRange constructor for an empty data range, to be used as a return value in functions that shall "fail" without exception.
This empty range must not be used other than by verifying that size() is 0
affected:
  OpenXLSX/headers/XLRowData.hpp
  OpenXLSX/sources/XLRowData.cpp


2024-04-25:
===========

IMPLEMENTED
===========
Pull Request: Get worksheet by index #179
Feature makes sense
--> implemented, had to also make XLWorkbook::sheet by index method compatible with whitespace nodes in sheetsNode
affects:
  OpenXLSX/headers/XLWorkbook.hpp XLWorksheet worksheet(uint16_t index) and XLChartsheet chartsheet(uint16_t index) and XLSheet XLWorkbook::sheet(uint16_t index)
  OpenXLSX/sources/XLWorkbook.cpp   "

Pull Request: Ignore whitespace in sharedStrings.xml #186
Bug tested, confirmed & fixed
--> implemented in Patch #6


my own patches:
---------------
Patch #10: Implemented compatibility with whitespace nodes in XLRow
affected:
  OpenXLSX/sources/XLRow.cpp XLRow::cellCount and XLRow::cells
235,236c235
<         auto node = m_rowNode->last_child_of_type(pugi::node_element);
<         if (node.empty())
---
>         if (!m_rowNode->last_child())
238c237
<         return XLCellReference(node.attribute("r").value()).column();
---
>         return XLCellReference(m_rowNode->last_child().attribute("r").value()).column();
268,270c267
<         XMLNode node = m_rowNode->last_child_of_type(pugi::node_element);
<         if (node.empty()) return XLRowDataRange(); // empty range
<         return XLRowDataRange(*m_rowNode, 1, XLCellReference(node.attribute("r").value()).column(), m_sharedStrings);
---
>         return XLRowDataRange(*m_rowNode, 1, XLCellReference(m_rowNode->last_child().attribute("r").value()).column(), m_sharedStrings);

Patch #9 new pugixml functions
		xml_node first_child_of_type(xml_node_type t = node_element) const;
          and 
		xml_node last_child_of_type(xml_node_type t = node_element) const;
  to deal with whitespace nodes in OpenXLSX: functions return a child matching the type t or an empty xml_node if no such child is found
affects:
  OpenXLSX/external/pugixml/pugixml.hpp
  OpenXLSX/external/pugixml/pugixml.cpp

Patch #8: Added a distinction between chartsheet and other nodes for XLQueryType::QuerySheetType, in order to support whitespaces in workbook.xml
affects:
  OpenXLSX/sources/XLDocument.cpp XLQuery XLDocument::execQuery(const XLQuery& query) const
  (result now set to XLContentType::Unknown if neither worksheet nor chartsheet)

Patch #7: Added an output formatting function to obtain a string representation of pugi::xml_node_type
affects:
  OpenXLSX/sources/utilities/XLUtilities.hpp inline std::string xml_node_type_string( pugi::xml_node_type t )

Patch #6: Reworked XLDocument.cpp XLDocument::open to be able to ignore shared string nodes other than node_element
affects:
  OpenXLSX/sources/XLDocument.cpp void XLDocument::open(const std::string& fileName)


Patch #5: Reworked XLUtilities.hpp getRowNode to be able to ignore nodes other than node_element
affects:
  OpenXLSX/sources/utilities/XLUtilities.hpp inline XMLNode getRowNode(XMLNode sheetDataNode, uint32_t rowNumber)

Patch #4: Throw exception in XLCellReference also from empty string, XLCellReference.cpp - TBD if this is compatible with OpenXLSX expectations
affects:
  OpenXLSX/sources/XLCellReference.cpp
78,80c77
<     if (cellAddress.empty() || !addressIsValid(m_row, m_column)) { // 2024-04-25: throw exception on empty string
<         throw XLCellAddressError("Cell reference is invalid");
< 		  // below: possibly deprecated (if exception remains)
---
>     if (!addressIsValid(m_row, m_column)) {
83a81
>         throw XLCellAddressError("Cell reference is invalid");


2024-04-24:
===========

my own patches:
---------------
Patch #3: Added functionality to skip whitespaces (anything but node_element) in XLCell XLWorksheet::cell(uint32_t rowNumber, uint16_t columnNumber) const
affects:
  OpenXLSX/sources/XLSheet.cpp XLCell XLWorksheet::cell(uint32_t rowNumber, uint16_t columnNumber) const

Patch #2: Added missing includes in XLCellValue.cpp
+  6:
#include <cassert>
#include <cstring>

Patch #1: Added support for getting a string representation of a cell value, regardless of cell data type:
affects
  OpenXLSX/sources/XLCellValue.hpp

Modifications:
+ 66:
typedef std::variant< std::string, int64_t, double, bool > XLCellValueType;
+264:
        /**
         * @brief get the cell value as a std::string, regardless of value type
         * @return A std::string representation of value
         * @throws XLValueTypeError if the XLCellValue object is not convertible to string.
         */
        std::string getAsString()
        {
            try {
                return std::visit( VisitXLCellValueTypeToString(), m_value );
            }
            catch( std::string s ) {
                throw XLValueTypeError("XLCellValue object is not convertible to string.");
            }
        }
-305:
        std::variant<std::string, int64_t, double, bool> m_value { std::string("") };                /**< The value contained in the cell. */
+322:
        XLCellValueType                                  m_value { std::string("") };                /**< The value contained in the cell. */
+325:
        //---------- Private Struct to enable XLValueType conversion to std::string ---------- //
        struct VisitXLCellValueTypeToString {
            std::string packageName = "VisitXLCellValueTypeToString";
            std::string operator()( int64_t v ) { return std::to_string( v ); }
            std::string operator()( double v ) { return std::to_string( v ); }
            std::string operator()( bool v ) { return v ? "true" : "false"; }
            // std::string operator()( struct timestamp v ) { return timestampString( v.seconds, v.microseconds, WITH_MS ); }
            std::string operator()( std::string v ) { return v; }
        };


2024-04-23:
===========

IMPLEMENTED:
--------------------------
Pull Request: Minor fixes #232
Duplicates:   gcc 13 compatibility fix #216

Pull Request: gcc 13 compatibility fix #216
Bug tested, confirmed & fixed
--> implemented
affects:
  OpenXLSX/sources/XLCellReference.cpp
  OpenXLSX/sources/XLColor.cpp

Pull Request: Fix OPENXLSX_LIBRARY_TYPE checks #225
Issue tested, confirmed & fixed
--> implemented
affects:
  OpenXLSX/CMakeLists.txt

Pull Request: Support Windows and AmigaOS style paths #191
Duplicates: Fix temporary archive init in Zippy::ZipArchive::Save #210 (for Windows)
TBD: Use case for AmigaOS? See TBDs above

Pull Request: Fix temporary archive init in Zippy::ZipArchive::Save #210
Issue untested, alternate fix implemented: backslashes are allowed in linux filenames, but replaced with forward slashes in windows paths
#				ifdef _WIN32
					std::replace( s.begin(), s.end(), '\\', '/' ); // pull request #210, alternate fix: fopen etc work fine with forward slashes
#				endif
--> implemented
affects:
  OpenXLSX/external/zippy/zippy.hpp


Pull Request: Enforce formula node order and properly convert cell type to number #189
Verified that LibreOffice saves XML nodes in the sequence that this patch will generate, so implementing the patch brings the file format in line with
 arguably the best verified non-MS application's output.
--> implemented
affects:
  OpenXLSX/sources/XLFormula.cpp

Pull Request: Fix changing values of cells of type "inlineStr" #188
Reviewed patch & verified that it makes sense
--> implemented
affects:
  OpenXLSX/sources/XLCellValue.cpp


REJECTED
--------
Pull Request: Fixed width and hidden attribute related methods in XLColumn.cpp #199
Reason:       author misunderstood the code, the columnNode() function returns a reference to the XMLNode under m_columnNode
               and while the patch would work, it's unnecessary

Pull Request: Set uniqueCount correctly in sharedStrings.xml #192
Related Issue: #187
Reason:       it is non-trivial to calculate both the correct uniqueCount and count, and both parameters are optional, but must appear together, as per:
     https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.sharedstringtable?view=openxml-3.0.1
Specifically, the proposed patch does not correctly calculate the uniqueCount, which is defined as uniqueness based on content + character level formatting

Pull Request: convert cell names to cell number and vice versa #164
Reason: Functionality is already available as member functions of XLCellReference::columnAsString and ::columnAsNumber
        Can use any existing reference, or by instantiating a simple XLCellReference ref("A1") to access the functions.

NOT IMPLEMENTED
---------------
Pull Request: Bump scipy from 1.5.4 to 1.10.0 in /Benchmarks/gbench #221
Reason: I have no idea what scipy is or does

Pull Request: Adding Named range and Table support #203
Reason: Too much code to review/verify as an outsider

Pull Request: Fixing problem with .pdb files in Debug version #178 
Reason: I do not understand the CMakeLists logic sufficiently to decide on this patch

Pull Request: Update README.md for Release vs Debug install #177 
Reason: Editorial, preference of the maintainer

Pull Request: Fix loading of xlsx files without xl/workbook.xml #185
-> Status: confirmed
Reason: TBD whether such a missing entry is a non-conformance with document standard and *should* lead to an exception

Pull Request: Update README.md with example for cmake config #175 
Reason: Editorial, preference of the maintainer

Pull Request: extend testing, add new function #165 
Reason: no bugs, testing functionality is unrelated to the library itself, maintainer to decide

Pull Request: Do not build optional targets when used with add_subdirectory() #157
Reason: I do not understand the CMakeLists logic sufficiently to decide on this patch

Pull Request: Readme clarification issue #124 #125
Reason: Editorial, preference of the maintainer



IDEA FOR A FUTURE STYLE IMPLEMENTATION
======================================
based on: formatted text is rich-text in XML, so one element node per unique style
  - user gets to "get style" for a given position in text (character):
   XLRichText.rows() / .row(index i) -> allows to extract text rows by index, removing the ambiguity of how to count a line break index
   XLRichText.row( i ) returns XLRichTextRow
   XLRichTextRow exposes:
    - std::string functionality for text manipulation, and on top of that:
	 - .formatAt( size_t index ) which returns an XLStyle object that contains the style applicable to that character
   XLRichText::insertText( XLRichTextRow row, XLRichText text ) // insert before row with given style
   XLRichText::insertText( XLRichTextRow row, std::string text, XLStyle style == __next__ )
   - when a row is inserted, it inherits the format as specified:
      __previous__: use style of the previous row
      __next__:     use style of row
      (custom XLStyle): use custom style (can be default, e.g. XLStyle{})
   XLRichText::insertText( XLRichTextRow row, int index, XLStyle style == __next__ )
      __previous__: use style of the previous character
      __next__:     use style of the next character
      (custom XLStyle): use custom style (can be default)

   XLRichText::prependText( XLRichTextRow row, std::string text, XLStyle style == __next__ )
    - equivalent to XLRichText::insertText( XLRichText.row( 0 ), text, style ) // NOTE: style == __previous__ is not allowed here
   XLRichText::appendText( XLRichTextRow row, std::string text, XLStyle style == __previous__ )
    - equivalent to XLRichText::insertText( XLRichText.row( XLRichText.rows().count() - 1 ), text, style ) // NOTE: style == __next__ is not allowed here

   XLRichText::format( int fromRow, int fromIndex, int toRow, int toIndex, XLStyle style )
    - applies the given style to the indicated range -> if it overlaps with other styles, this will split rich text sections as needed, e.g.:
      * assume simplified XLRichTextPos pos_i( row_i, index_i )
      * existing style_a from pos_i to pos_j
      * new style_b applied to pos_k to pos_l with pos_k > pos_i and pos_l < pos_j
      * resulting style sections:
        [pos_i;pos_k[ style_a
        [pos_k;pos_l] style_b
        ]pos_l;pos_j] style_a

   NOTE: for all inserts, text can have line breaks & will be inserted into the XLRichText accordingly
   The underlying cell string value is updated accordingly (with the access logic to shared strings)

   For such manipulations, the user has to create an XLRichText by accessing a cell intentionally as rich text, which will load the cell contents into the above structure and allow according manipulations on the underlying XML. For repeated access, it would be recommended to *not* work on temporary objects, but keep the XLRichText alive until operations on the cell are complete.

   A bunch of helper functions could then be added one after another, e.g.:
   * introduce XLRichTextCharacter with iterator traits (and a parent property that points to the row)
   * auto-select format ranges based on an XLRichTextRow or XLRichTextCharacters
     --> XLRichText::format( XLRichTextRow row ), XLRichText::format( XLRichTextRow fromRow, toRow ), XLRichText::format( XLRichTextCharacter fromChar, XLRichTextCharacter toChar )

   TBD: how to decide on duplication / deduplication of XLStyles in the styles table
